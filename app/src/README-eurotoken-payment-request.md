## EuroToken Multi-Currency Payment Request Feature For the SuperApp

The payment request system (Dutch: Betaalverzoek) has been increasingly popular among the population due to its simplicity in payment request and management. Implementing payment requests would potentially enhance the usability of the EuroToken among the consumers. This feature is widely implemented nowadays, however, it has not been developed into the SuperApp yet. Furthermore, our developed feature also enhances adoptability by enabling future users to request and pay in multiple currencies, by automatically connecting to a trusted exchange and carry out the "swap" on behave of the user.

At the moment, the implementation only supports EUR and EuroToken. This implementation also tests the usability of the REST API of the exchange by putting it in use in the different features. At the same time we would like to identify potential weakness of the Value Transfer app and provide suggestion for the future.


## Prerequisite
[EuroToken: An offline-capable Central Bank Digital Currency](https://repository.tudelft.nl/islandora/object/uuid%3A132faae8-6883-454f-a8ce-94735340dce9?collection=education)

[EuroToken implementation in the Superapp](https://github.com/Tribler/trustchain-superapp/tree/master/eurotoken/src/main/java/nl/tudelft/trustchain/eurotoken)

## Design & Implementation

### Payment request link creation
The payment request link creation starts with the receiver. The receiver chooses a currency she would like to paid with and add addition information (amount, publickey, IBAN, etc) before she connects to the exchange server to request parameters in order to generate a link for sharing.

In order to make sure that payment information is available at point of payment, we have chosen to make use of a payment request ID which will be generated by the exchange server. This information is also being kept by the exchange server (but can be extended to a dedicated payment request server in the future, if needed). Even though this is not a decentralized way to do book keeping of payment request information, it ensures that payer can still receive payment information in case the receiver is not online, since the exchange is always online and operational.

Once a link is created on the receiver side, the receiver can proceed to share link through different communication channels in our implementation. We have also extend front-end elements to facilitate this.

![image](https://user-images.githubusercontent.com/16018391/164205983-96833ea2-0437-42c0-8cc5-a848b696bd62.png)

### Link sharing
Assuming the link is shared through secure communication channels, the link will reach the receiver side untampered.

However, if a link is shared through insecure channels where MITM can intercept and tamper with the information in the link, then the payer will pay to the wrong receiver. Hence, we recommended using only end-to-end encrypted communication channels to share the link.

In order to enhance security of link sharing through insecure channels (is is sometimes still used nowadays), we implemented link signature. The receiver sign the link with his or her private key before sharing it to the payer through insecure channels, whose will validate the signature upon receiving the link. This will ONLY work if the payer already somehow has the public key of the receiver in list of contact contained in his device. A practical approach for this would be the one-time sharing of public key in person/ through secure channels and make use of link signature for payment requests subsequently. Another application for this in the future would be sending payment to organizations or goverment entities by beforehand verify signatures with their public key on their trusted sources such as websites.


### Two-way currency transaction flow

Our implementation supports the following payment flow of currency with the payment requests:
(1) Paying in EuroToken and receiving EuroToken
(2) Paying in Euro and receiving EuroToken
(3) Paying in Eurotoken and receiving Euro

Option (1) involves using the existing EuroToken transfer mechanism while option (2) involves the EuroToken Exchange server which will be explained below.

Implementing this enable the payer to pay without having the required funding in either network, Euro or EuroToken. In short, it allows participation in the EuroToken network without actually use/have EuroTokens.

### Mid-payment currency exchange


In order to enable currency exchange during the payment, we modified both the tokenization and detokenization flow (originally described in the EuroToken graduation thesis)  in order to "swap" the currencies for the multi-currency payment to work.

After the payment request link is received by the intended recipient (payer), there are 3 scenarios - depending on the type of payment both the payer and receiver decided to use:

![image](https://user-images.githubusercontent.com/16018391/163803312-12c46953-4271-4004-8470-c476f19db82c.png) (Credit: Erwin Nieuwlaar - @Nieuwlaar)

Scenario 2 and 3 involves making use of the REST API of the EuroToken exchange, this is due to the reason that the payer and receiver makes use of different currencies and there is a need to exchange it at point of transaction. In order to make sure that resources are not being wasted on unecessary exchange of currency, the exchange process is only initiated after the payer has decided to pay (i.e. clicking on pay button the app).

In order to make sure that payment information is available at point of payment, we have chosen to make use of a payment request ID which will be generated by the exchange server. This information is also being kept by the exchange server (but can be extended to a dedicated payment request server in the future, if needed). Even though this is not a decentralized way to do book keeping of payment request information, it ensures that payer can still receive payment information in case the receiver is not online, since the exchange is always online and operational.

There is one problem with this approach. If a link is shared through insecure channels where MITM can intercept and tamper with the information in the link, then the payer will pay to the wrong receiver. Hence, we recommended using only end-to-end encrypted communication channels to share the link.

In order to enhance security of link sharing through insecure channels (is is sometimes still used nowadays), we implemented link signature. The receiver sign the link with his or her private key before sharing it to the payer through insecure channels, whose will validate the signature upon receiving the link. This will ONLY work if the payer already somehow has the public key of the receiver in list of contact contained in his device. A practical approach for this would be the one-time sharing of public key in person/ through secure channels and make use of link signature for payment requests subsequently. Another application for this in the future would be sending payment to organizations or goverment entities by beforehand verify signatures with their public key on their trusted sources such as websites.

## Installation
## Before running:
To make the process of link sharing and receiving the transactions easier, we have made some changes to the exchange, namely, we added a method called `check_payments_done` in the `backend/stablecoin/stablecoin.py`. This method checks every 5 seconds for pending transactions to see if they are paid. If so, it will process the payment to finalize the transactions. This is especially relevant when the user uses the second scenario, namely Euro to EuroToken in which a Tikkie link will be used to pay in Euro.

However, this change is not necessary when the server is deployed. When the server is deployed a webhook should be implemented. The webhook will be called by the bank (e.g., in case of Tikkie link, the bank is ABN AMRO) when the user has finished the payment and paid, and then the exchange server can process the transaction. You can find a PR of this change to the exchange server [here.](https://github.com/KoningR/stablecoin-exchange/pull/1)

- Setup the exchange server (https://github.com/KoningR/stablecoin-exchange) (follow its readme)
- After exchange setup, go to `run_coin.py` and change `GATEWAY_HOSTNAME` to the IP address of your computer running the python server
- Now make some changes to TrustChain App. Basically change my IP (`192.168.0.106`) to your computer IP
- go to `app/src/main/res/xml/network_security_config.xml` and change `192.168.0.106` to your local IP
- go to `common/build.gradle` and change ONLY IP of `DEFAULT_GATEWAY_HOST` to your IP
- Run backend exchange with `python3 run_coin.py`

Furthermore:

- Android by default doesn't allow for clear traffic (HTTP). So to test the app with a 

exchange server running on localhost you should add your IP address to ```app/src/main/res/xml/network_security_config.xml```:

```
        <domain includeSubdomains="true">127.0.0.1</domain>
```

- In ```common/build.gradle``` change ```DEFAULT_GATEWAY_HOST``` to the IP and Port of the exchange.
Note that the port is the same as REST API port and not the port running IPV8 server.


***TIP***: if you want to bypass the wallet creation step in the app, you can do it in the ```valuetransfer/src/main/java/nl/tudelft/trustchain/valuetransfer/ValueTransferMainActivity.kt``` by changing the following line

```
    private val walletOverviewFragment = WalletOverviewFragment()
```
to this line
```
    private val walletOverviewFragment = ExchangeFragment()
```
### Steps:
- `git clone --recurse-submodules` https://github.com/Nieuwlaar/trustchain-superapp.git
- Run TrustChain app

## Challenges:
Working with this project came along with some challenges, namely:

- We could not fully test scenario 3 due to not being able to acquire the live API keys (Thanks to Robbert for trying though!)
- The superapp code is not tested, hence there could be hidden bugs that might have contributed to difficulties of the project
- There was no documentation with the code we worked with. During the progress, we did not know how to use specific code and has to go throug all the code with sometimes having to debug that code to understand it.
- By default, ConfiApp used QR code as E2E communication, which enable the application to know the receiver of the payment - the receiver is known. However, with our payment request implementation, we can create and share link but there is actually no way to know who is the receiver for sure (IP address, Port, Identity, etc).
- When you doing a project that is outsourced, you need coding conventions. With the superapp code there were no coding conventions. We did not know where to put our codes and what are the structure. Coding style were also inconsistent throughout the project.


## Suggestions:
- The link needs to be set up with a website which display payment information and methods so that the payer who does not have the EuroToken app can still make use of the EuroToken payment request system.

- Even though our implementation of link sharing is very straight forward, during this progress there is no guarantee that the person behind the public key is the intended benficiary. The suggestion for the future is that, a validation mechanism should be implemented either in the server (with a trusted authority) or user to make sure the link is shared by a receiver linked to the strong identity (for example passport-enrolled identity in the app)

- Implement a multi-payer system to enable multiple payer pay to same user and overview of payers to the payment system

- Tying the payment request to the identity of the requester

- Advertise and update IP and ports of clients to the exchange server so that they can be found there easily

- Implement signature primitives provided by IPv8

- Implement a multi-payer system to enable multiple payer pay to same user and overview of payers to the payment system

- Tying the payment request to the identity of the requester

- Advertise and update IP and ports of clients to the exchange server so that they can be found there easily


## Testings:

Tests were not written for Valuetransfer app previously, however we tested our code. There are two types of test you can find in the repository:
Unit Tests:

- Handling Incoming links
- Correct Amount input
- IBAN validation

Integration Tests:
- Link Signature validation


We had difficulties with setting E2E intergration tests since you will need to setup an instance of IPv8. We have also tried to do mock testing, however we came across a variety of problems.



## Notes

To make the process of link sharing and receiving the transactions easier, we have made some changes to the exchange, namely, we added a method called ```check_payments_done``` in the ```backend/stablecoin/stablecoin.py```. This method checks every 5 seconds for pending transactions to see if they are paid. If so, it will process the payment to finalize the transactions. This is especially relevant when the user uses the second scenario, namely Euro to EuroToken in which a Tikkie link will be used to pay in Euro.

However, this change is not necessary when the server is deployed. When the server is deployed a webhook should be implemented. The webhook will be called by the bank (e.g., in case of Tikkie link, the bank is ABN AMRO) when the user has finished the payment and paid, and then the exchange server can process the transaction.

